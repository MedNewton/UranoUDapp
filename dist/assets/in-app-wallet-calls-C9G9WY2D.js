import{af as b,Q as f,ag as g,ah as h,ai as p,aj as m}from"./index-B7UgA71q.js";import{sendBatchTransaction as w}from"./send-batch-transaction-Rzdu1kJj.js";async function H(o){const s=await b(o);return f(s)}const u=new g(1e3);async function T(o){const{account:s,calls:l}=o,c=l.map(n=>({...n,chain:o.chain})),a=[],e=m(65);if(u.set(e,a),s.sendBatchTransaction){const n=await w({account:s,transactions:c});a.push(n.transactionHash),u.set(e,a)}else for(const n of c){const r=await H({account:s,transaction:n});a.push(r.transactionHash),u.set(e,a)}return e}async function y(o){const{chain:s,client:l,id:c}=o,a=u.get(c);if(!a)throw new Error("Failed to get calls status, unknown bundle id");const e=h({chain:s,client:l});let n="success";const r=await Promise.all(a.map(d=>p(e,{hash:d}).then(t=>({blockHash:t.blockHash,blockNumber:t.blockNumber,gasUsed:t.gasUsed,logs:t.logs.map(i=>({address:i.address,data:i.data,topics:i.topics})),status:t.status,transactionHash:t.transactionHash})).catch(()=>(n="pending",null))));return{atomic:!1,chainId:s.id,id:c,receipts:r.filter(d=>d!==null),status:n,statusCode:200,version:"2.0.0"}}async function C(o){const{chain:s,client:l,id:c}=o,a=u.get(c);if(!a)throw new Error("Failed to get calls status, unknown bundle id");const e=h({chain:s,client:l});let n=200;const r=[];for(const d of a)try{const t=await p(e,{hash:d});r.push({blockHash:t.blockHash,blockNumber:`0x${t.blockNumber.toString(16)}`,gasUsed:`0x${t.gasUsed.toString(16)}`,logs:t.logs.map(i=>({address:i.address,data:i.data,topics:i.topics})),status:t.status==="success"?"0x1":"0x0",transactionHash:t.transactionHash})}catch{n=100}return{atomic:!1,chainId:`0x${s.id.toString(16)}`,id:c,receipts:r,status:n,version:"2.0.0"}}export{y as inAppWalletGetCallsStatus,C as inAppWalletGetCallsStatusRaw,T as inAppWalletSendCalls};
